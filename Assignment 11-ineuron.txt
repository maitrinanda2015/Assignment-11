<aside>
ğŸ’¡ **1**

Given a non-negative integerÂ `x`, returnÂ *the square root of*Â `x`Â *rounded down to the nearest integer*. The returned integer should beÂ **non-negative**Â as well.

YouÂ **must not use**Â any built-in exponent function or operator.

Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.

Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
ans-:
public class SquareRoot {
    public static int sqrt(int x) {
        if (x == 0) {
            return 0;
        }

        int left = 1;
        int right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mid <= x / mid && (mid + 1) > x / (mid + 1)) {
                return mid;
            } else if (mid > x / mid) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        return -1; // This line should not be reached for non-negative inputs
    }

    public static void main(String[] args) {
        int x = 4;
        int result = sqrt(x);
        System.out.println("Square root of " + x + " is: " + result);

        x = 8;
        result = sqrt(x);
        System.out.println("Square root of " + x + " is: " + result);
    }
}
<aside>
ğŸ’¡ **2**

A peak element is an element that is strictly greater than its neighbors.

Given aÂ **0-indexed**Â integer arrayÂ `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index toÂ **any of the peaks**.

You may imagine thatÂ `nums[-1] = nums[n] = -âˆ`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs inÂ `O(log n)`Â time.

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.

ans-:
public class PeakElement {
    public static int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 1};
        int peakIndex = findPeakElement(nums);
        int peakValue = nums[peakIndex];
        System.out.println("Peak element index: " + peakIndex);
        System.out.println("Peak element value: " + peakValue);

        nums = new int[]{1, 2, 1, 3, 5, 6, 4};
        peakIndex = findPeakElement(nums);
        peakValue = nums[peakIndex];
        System.out.println("Peak element index: " + peakIndex);
        System.out.println("Peak element value: " + peakValue);
    }
}
<aside>
ğŸ’¡ **3**

****

Given an arrayÂ `nums`Â containingÂ `n`Â distinct numbers in the rangeÂ `[0, n]`, returnÂ *the only number in the range that is missing from the array.*
ans-:
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.

Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.

Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

ans-:
public class MissingNumber {
    public static int findMissingNumber(int[] nums) {
        int n = nums.length;
        int missing = n;

        for (int i = 0; i < n; i++) {
            missing ^= i ^ nums[i];
        }

        return missing;
    }

    public static void main(String[] args) {
        int[] nums = {3, 0, 1};
        int missingNumber = findMissingNumber(nums);
        System.out.println("Missing number: " + missingNumber);

        nums = new int[]{0, 1};
        missingNumber = findMissingNumber(nums);
        System.out.println("Missing number: " + missingNumber);

        nums = new int[]{9, 6, 4, 2, 3, 5, 7, 0, 1};
        missingNumber = findMissingNumber(nums);
        System.out.println("Missing number: " + missingNumber);
    }
}
<aside>
ğŸ’¡ **4**

Given an array of integersÂ `nums`Â containingÂ `n + 1`Â integers where each integer is in the rangeÂ `[1, n]`Â inclusive.

There is onlyÂ **one repeated number**Â inÂ `nums`, returnÂ *thisÂ repeatedÂ number*.

You must solve the problemÂ **without**Â modifying the arrayÂ `nums`Â and uses only constant extra space.

ans-:
Input: nums = [1,3,4,2,2]
Output: 2

Input: nums = [3,1,3,4,2]
Output: 3

ans-:
public class RepeatedNumber {
    public static int findRepeatedNumber(int[] nums) {
        int tortoise = nums[0];
        int hare = nums[0];

        // Find the intersection point of the two pointers
        do {
            tortoise = nums[tortoise];
            hare = nums[nums[hare]];
        } while (tortoise != hare);

        // Move the tortoise to the beginning and advance both pointers at the same speed
        tortoise = nums[0];
        while (tortoise != hare) {
            tortoise = nums[tortoise];
            hare = nums[hare];
        }

        return hare;
    }

    public static void main(String[] args) {
        int[] nums = {1, 3, 4, 2, 2};
        int repeatedNumber = findRepeatedNumber(nums);
        System.out.println("Repeated number: " + repeatedNumber);

        nums = new int[]{3, 1, 3, 4, 2};
        repeatedNumber = findRepeatedNumber(nums);
        System.out.println("Repeated number: " + repeatedNumber);
    }
}
5.Given two integer arraysÂ nums1Â andÂ nums2, returnÂ an array of their intersection. Each element in the result must beÂ uniqueÂ and you may return the result inÂ any order.
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
ans-:
import java.util.HashSet;
import java.util.ArrayList;
import java.util.List;

public class ArrayIntersection {
    public static int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> set = new HashSet<>();
        for (int num : nums1) {
            set.add(num);
        }

        List<Integer> intersectionList = new ArrayList<>();
        for (int num : nums2) {
            if (set.contains(num)) {
                intersectionList.add(num);
                set.remove(num); // To ensure uniqueness
            }
        }

        int[] intersectionArray = new int[intersectionList.size()];
        for (int i = 0; i < intersectionList.size(); i++) {
            intersectionArray[i] = intersectionList.get(i);
        }

        return intersectionArray;
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 2, 2, 1};
        int[] nums2 = {2, 2};
        int[] intersectionArray = intersection(nums1, nums2);
        System.out.print("Intersection: [");
        for (int i = 0; i < intersectionArray.length; i++) {
            System.out.print(intersectionArray[i]);
            if (i != intersectionArray.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");

        nums1 = new int[]{4, 9, 5};
        nums2 = new int[]{9, 4, 9, 8, 4};
        intersectionArray = intersection(nums1, nums2);
        System.out.print("Intersection: [");
        for (int i = 0; i < intersectionArray.length; i++) {
            System.out.print(intersectionArray[i]);
            if (i != intersectionArray.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
<aside>
ğŸ’¡ **6**

Suppose an array of lengthÂ `n`Â sorted in ascending order isÂ **rotated**Â betweenÂ `1`Â andÂ `n`Â times. For example, the arrayÂ `nums = [0,1,2,4,5,6,7]`Â might become:

- `[4,5,6,7,0,1,2]`Â if it was rotatedÂ `4`Â times.
- `[0,1,2,4,5,6,7]`Â if it was rotatedÂ `7`Â times.

Notice thatÂ **rotating**Â an arrayÂ `[a[0], a[1], a[2], ..., a[n-1]]`Â 1 time results in the arrayÂ `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated arrayÂ `nums`Â ofÂ **unique**Â elements, returnÂ *the minimum element of this array*.

You must write an algorithm that runs inÂ `O(log n) time.`

Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.

Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.

Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times.
ans-:
public class MinimumInRotatedSortedArray {
    public static int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        // If the array is not rotated, the first element is the minimum
        if (nums[left] <= nums[right]) {
            return nums[left];
        }

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return nums[left];
    }

    public static void main(String[] args) {
        int[] nums = {3, 4, 5, 1, 2};
        int min = findMin(nums);
        System.out.println("Minimum element: " + min);

        nums = new int[]{4, 5, 6, 7, 0, 1, 2};
        min = findMin(nums);
        System.out.println("Minimum element: " + min);

        nums = new int[]{11, 13, 15, 17};
        min = findMin(nums);
        System.out.println("Minimum element: " + min);
    }
}
<aside>
ğŸ’¡ **7**

Given an array of integersÂ `nums`Â sorted in non-decreasing order, find the starting and ending position of a givenÂ `target`Â value.

IfÂ `target`Â is not found in the array, returnÂ `[-1, -1]`.

You mustÂ write an algorithm withÂ `O(log n)`Â runtime complexity.
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

Input: nums = [], target = 0
Output: [-1,-1]

public class FindFirstLastPosition {
    public static int[] searchRange(int[] nums, int target) {
        int[] result = {-1, -1};

        int leftIndex = findLeftmostIndex(nums, target);
        if (leftIndex == -1) {
            return result;
        }

        int rightIndex = findRightmostIndex(nums, target);

        result[0] = leftIndex;
        result[1] = rightIndex;

        return result;
    }

    private static int findLeftmostIndex(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int leftIndex = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] >= target) {
                right = mid - 1;
                if (nums[mid] == target) {
                    leftIndex = mid;
                }
            } else {
                left = mid + 1;
            }
        }

        return leftIndex;
    }

    private static int findRightmostIndex(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int rightIndex = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] <= target) {
                left = mid + 1;
                if (nums[mid] == target) {
                    rightIndex = mid;
                }
            } else {
                right = mid - 1;
            }
        }

        return rightIndex;
    }

    public static void main(String[] args) {
        int[] nums = {5, 7, 7, 8, 8, 10};
        int target = 8;
        int[] result = searchRange(nums, target);
        System.out.println("Range: [" + result[0] + ", " + result[1] + "]");

        nums = new int[]{5, 7, 7, 8, 8, 10};
        target = 6;
        result = searchRange(nums, target);
        System.out.println("Range: [" + result[0] + ", " + result[1] + "]");

        nums = new int[]{};
        target = 0;
        result = searchRange(nums, target);
        System.out.println("Range: [" + result[0] + ", " + result[1] + "]");
    }
}
8.Given two integer arraysÂ nums1Â andÂ nums2, returnÂ an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result inÂ any order.

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.

ans-:
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class IntersectionOfArrays {
    public static int[] intersect(int[] nums1, int[] nums2) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();

        // Count the frequencies of elements in nums1
        for (int num : nums1) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        List<Integer> intersectionList = new ArrayList<>();

        // Check for intersection while iterating through nums2
        for (int num : nums2) {
            if (frequencyMap.containsKey(num) && frequencyMap.get(num) > 0) {
                intersectionList.add(num);
                frequencyMap.put(num, frequencyMap.get(num) - 1);
            }
        }

        int[] intersection = new int[intersectionList.size()];

        // Convert the intersection list to an array
        for (int i = 0; i < intersectionList.size(); i++) {
            intersection[i] = intersectionList.get(i);
        }

        return intersection;
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 2, 2, 1};
        int[] nums2 = {2, 2};
        int[] intersection = intersect(nums1, nums2);
        System.out.print("Intersection: [");
        for (int i = 0; i < intersection.length; i++) {
            System.out.print(intersection[i]);
            if (i != intersection.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");

        nums1 = new int[]{4, 9, 5};
        nums2 = new int[]{9, 4, 9, 8, 4};
        intersection = intersect(nums1, nums2);
        System.out.print("Intersection: [");
        for (int i = 0; i < intersection.length; i++) {
            System.out.print(intersection[i]);
            if (i != intersection.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}






